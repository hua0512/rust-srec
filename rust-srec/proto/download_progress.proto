syntax = "proto3";

package download_progress;

// Event types for WebSocket messages
enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0;
  EVENT_TYPE_SNAPSHOT = 1;
  EVENT_TYPE_DOWNLOAD_META = 2;
  EVENT_TYPE_DOWNLOAD_METRICS = 3;
  EVENT_TYPE_SEGMENT_COMPLETED = 4;
  EVENT_TYPE_DOWNLOAD_COMPLETED = 5;
  EVENT_TYPE_DOWNLOAD_FAILED = 6;
  EVENT_TYPE_DOWNLOAD_CANCELLED = 7;
  EVENT_TYPE_ERROR = 8;
  EVENT_TYPE_DOWNLOAD_REJECTED = 9;
}

// Server-to-client message envelope
message WsMessage {
  EventType event_type = 1;
  oneof payload {
    DownloadSnapshot snapshot = 2;
    DownloadMeta download_meta = 3;
    DownloadMetrics download_metrics = 4;
    SegmentCompleted segment_completed = 5;
    DownloadCompleted download_completed = 6;
    DownloadFailed download_failed = 7;
    DownloadCancelled download_cancelled = 8;
    ErrorPayload error = 9;
    DownloadRejected download_rejected = 10;
  }
}

// Client-to-server message for filtering
message ClientMessage {
  oneof action {
    SubscribeRequest subscribe = 1;
    UnsubscribeRequest unsubscribe = 2;
  }
}

message SubscribeRequest {
  string streamer_id = 1;
}

message UnsubscribeRequest {}

// Initial snapshot of all active downloads
message DownloadSnapshot {
  repeated DownloadState downloads = 1;
}

// A complete download state, split into metadata and metrics.
message DownloadState {
  DownloadMeta meta = 1;
  DownloadMetrics metrics = 2;
}

// Download metadata (low frequency).
message DownloadMeta {
  string download_id = 1;
  string streamer_id = 2;
  string session_id = 3;
  string engine_type = 4;
  int64 started_at_ms = 5;
  // Monotonic (best-effort) update timestamp to help clients coalesce meta updates.
  // Clients should ignore meta updates older than what they've already applied.
  int64 updated_at_ms = 8;
  // CDN host for this download (host[:port]).
  string cdn_host = 6;
  // The actual stream URL being downloaded (may contain signed query params).
  string download_url = 7;
}

// Download metrics (high frequency).
message DownloadMetrics {
  string download_id = 1;
  string status = 2;
  uint64 bytes_downloaded = 3;
  double duration_secs = 4;
  uint64 speed_bytes_per_sec = 5;
  uint32 segments_completed = 6;
  double media_duration_secs = 7;
  double playback_ratio = 8;
}

// Segment completed event
message SegmentCompleted {
  string download_id = 1;
  string streamer_id = 2;
  string segment_path = 3;
  uint32 segment_index = 4;
  double duration_secs = 5;
  uint64 size_bytes = 6;
  string session_id = 7;
}

// Download completed event
message DownloadCompleted {
  string download_id = 1;
  string streamer_id = 2;
  string session_id = 3;
  uint64 total_bytes = 4;
  double total_duration_secs = 5;
  uint32 total_segments = 6;
}

// Download failed event
message DownloadFailed {
  string download_id = 1;
  string streamer_id = 2;
  string session_id = 3;
  string error = 4;
  bool recoverable = 5;
}

// Download cancelled event
message DownloadCancelled {
  string download_id = 1;
  string streamer_id = 2;
  string session_id = 3;
  // Download stop cause (best-effort).
  // Values are produced by server-side `DownloadStopCause::as_str()`.
  string cause = 4;
}

// Download rejected event (rejected before starting).
message DownloadRejected {
  string streamer_id = 1;
  string session_id = 2;
  string reason = 3;
  uint64 retry_after_secs = 4;
  bool recoverable = 5;
}

// Error payload for service errors
message ErrorPayload {
  string code = 1;
  string message = 2;
}
